---
import "../styles/site.css";
import { getLastUpdated } from "../utils/getLastUpdated";
import { getPostTimeHHMMSS } from "../utils/getPostTime";
import { SITE_NAME, SITE_DESCRIPTION } from "../lib/blog.js";

const {
  frontmatter = {},
  title: propTitle,
  description: propDescription,
  showDate: propShowDate,
  date: propDate,
  allowContentH1: propAllowContentH1,
} = Astro.props;

const siteName = SITE_NAME;
const title = propTitle ?? frontmatter.title ?? siteName;
const description = propDescription ?? frontmatter.description ?? SITE_DESCRIPTION;

const fullTitle = title === siteName ? siteName : `${title} | ${siteName}`;
const showDate = propShowDate ?? frontmatter.showDate ?? false;
const rawDate = propDate ?? frontmatter.date;

// ★ 本文側の h1 を許可したいページだけ true
const allowContentH1 =
  propAllowContentH1 ?? frontmatter.allowContentH1 ?? false;

// frontmatter の date は「YYYY-MM-DD」だけにしたい前提。
// ただし Astro/YAML 側で Date オブジェクトに変換されることがあり、その場合
// String(Date) → "Thu Jan ..." になって判定不能 + JST 表示で 09:00:00 に見える。
// ここでは「日付だけ」を常に正規化して扱う。
const rawDateValue = rawDate ?? null;

let rawDateStr: string | null = null;
let dateOnlyStr: string | null = null;

if (rawDateValue instanceof Date && !isNaN(rawDateValue.getTime())) {
  // Date に変換されていても、元は YYYY-MM-DD の想定なので日付部分だけ抜く
  dateOnlyStr = rawDateValue.toISOString().slice(0, 10);
  rawDateStr = dateOnlyStr;
} else if (rawDateValue != null) {
  rawDateStr = String(rawDateValue);
  if (/^\d{4}-\d{2}-\d{2}$/.test(rawDateStr)) dateOnlyStr = rawDateStr;
}

const isDateOnly = !!dateOnlyStr;

// frontmatter は date: YYYY-MM-DD のままにしたいので、時刻は git から推定する
// - その記事ファイルの「追加（初回コミット）」時刻（取れなければ最新コミット）
// - git が無い/履歴が浅い場合は 00:00:00
let inferredHHMMSS: string | null = null;
if (showDate && isDateOnly) {
  try {
    inferredHHMMSS = getPostTimeHHMMSS(Astro.url.pathname);
  } catch {
    inferredHHMMSS = null;
  }
}

// 記事内（showDate=true）の表示用
// - dateOnly のとき："YYYY-MM-DD HH:MM:SS"（09:00 事故を回避するため Date を介さない）
// - それ以外：従来通り Date を parse して JST 表示
let isoDate: string | null = null;
let displayDateTime: string | null = null;

if (dateOnlyStr) {
  const hhmmss = inferredHHMMSS ?? "00:00:00";
  displayDateTime = `${dateOnlyStr} ${hhmmss}`;
  isoDate = `${dateOnlyStr}T${hhmmss}+09:00`;
} else {
  const dateObj = rawDateStr ? new Date(rawDateStr) : null;
  const isValidDate = dateObj instanceof Date && !isNaN(dateObj.getTime());
  if (isValidDate && dateObj) {
    isoDate = dateObj.toISOString();

    const parts = new Intl.DateTimeFormat("ja-JP", {
      timeZone: "Asia/Tokyo",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false,
    })
      .formatToParts(dateObj)
      .reduce((acc, p) => {
        if (p.type !== "literal") acc[p.type] = p.value;
        return acc;
      }, {});

    displayDateTime = `${parts.year}-${parts.month}-${parts.day} ${parts.hour}:${parts.minute}:${parts.second}`;
  }
}

// NOTE: siteUrl はあなたの公開URLに合わせて固定（Astro.site があればそちら優先）
const siteUrl = "https://itashin1201.github.io";
const site = Astro.site ?? new URL(siteUrl);

const pageUrl = new URL(Astro.url.pathname, site).toString();
const canonicalUrl = pageUrl;

const base = import.meta.env.BASE_URL;

const ogImageUrl = new URL(`${base}og.png`, site).toString();
const ogType = showDate && isoDate ? "article" : "website";

// ★ 失敗しても落ちないようにフォールバック
let lastUpdated = null;
try {
  lastUpdated = await getLastUpdated();
} catch {
  lastUpdated = null;
}

// ===== ナビ制御 =====
const normalizePath = (p) => (p.endsWith("/") ? p : `${p}/`);
const currentPath = normalizePath(Astro.url.pathname);

// NOTE: BASE_URL 付き/無しのどちらでも判定が安定するように末尾で判定
const isHome = currentPath === normalizePath(base) || currentPath === "/";
const isBlogIndex = currentPath.endsWith("/blog/");
const isSearchPage = currentPath.endsWith("/search/");
const isBlogChild = currentPath.includes("/blog/") && !isBlogIndex;
---

<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>{fullTitle}</title>
    <meta name="description" content={description} />

    <meta name="color-scheme" content="light dark" />

    <!-- Canonical -->
    <link rel="canonical" href={canonicalUrl} />

    <!-- RSS -->
    <link
      rel="alternate"
      type="application/rss+xml"
      title={`${siteName} RSS`}
      href={`${base}rss.xml`}
    />

    <!-- Open Graph -->
    <meta property="og:site_name" content={siteName} />
    <meta property="og:locale" content="ja_JP" />
    <meta property="og:title" content={fullTitle} />
    <meta property="og:description" content={description} />
    <meta property="og:type" content={ogType} />
    <meta property="og:url" content={pageUrl} />
    <meta property="og:image" content={ogImageUrl} />
    <meta property="og:image:alt" content={fullTitle} />

    {ogType === "article" && isoDate && (
      <meta property="article:published_time" content={isoDate} />
    )}

    <!-- Twitter / X -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={fullTitle} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:url" content={pageUrl} />
    <meta name="twitter:image" content={ogImageUrl} />
    <meta name="twitter:image:alt" content={fullTitle} />

    <link rel="icon" href={`${base}favicon.png`} />
    <slot name="head" />

    <!-- ★ showDate（=Layoutでh1出す）時だけ、本文先頭h1を非表示にして二重を防ぐ -->
    {showDate && !allowContentH1 && <style>{`article h1{display:none}`}</style>}

    <!-- テーマ：描画前に data-theme をセット（ちらつき防止） -->
    <script>
      (() => {
        const key = "theme";
        let saved = null;
        try {
          saved = localStorage.getItem(key);
        } catch {
          saved = null;
        }

        let prefersDark = false;
        try {
          prefersDark = window
            .matchMedia("(prefers-color-scheme: dark)")
            .matches;
        } catch {
          prefersDark = false;
        }

        const theme = saved ?? (prefersDark ? "dark" : "light");
        document.documentElement.dataset.theme = theme;
      })();
    </script>
  </head>

  <body>
    <a class="skip-link" href="#content">本文へ</a>

    <button
      id="theme-toggle"
      type="button"
      aria-label="Toggle theme"
      aria-pressed="false"
    >
      dark
    </button>

    <div class="page">

    <main id="content" class="container">
      {!isHome && (
        <nav class="breadcrumb" aria-label="Primary">
          <a href={base}>Home</a>
          {/* Blog（all=ブログTOP）のときは Blog を出さず、Home / Search にする */}
          {!isBlogIndex && (
            <>
              <span class="sep" aria-hidden="true"> / </span>
              <a
                href={`${base}blog/`}
                aria-current={(isBlogIndex || isBlogChild) ? "page" : undefined}
              >
                Blog
              </a>
            </>
          )}
          {!isSearchPage && (
            <>
              <span class="sep" aria-hidden="true"> / </span>
              <a href={`${base}search/`}>Search</a>
            </>
          )}
        </nav>
      )}

      {showDate && (
        <header class="post-header">
          <div>
            <div class="post-site">{siteName}</div>
            <h1 class="post-title">{title}</h1>
          </div>

          {displayDateTime && (
            <time class="post-date" datetime={isoDate}>
              {displayDateTime}
            </time>
          )}
        </header>
      )}

      <article>
        <slot />
      </article>
    </main>

    <footer class="site-footer">
      <div class="copyright">© {new Date().getFullYear()} itashin</div>
      {lastUpdated && <div class="last-updated">最終更新：{lastUpdated}</div>}
    </footer>
    </div>

    <script>
      // ===== Theme toggle =====
      (() => {
        const key = "theme";
        const btn = document.getElementById("theme-toggle");
        if (!btn) return;

        const setButton = (theme) => {
          btn.textContent = theme === "dark" ? "light" : "dark";
          btn.setAttribute("aria-pressed", String(theme === "dark"));
        };

        const getInitialTheme = () => {
          const current = document.documentElement.dataset.theme;
          if (current === "dark" || current === "light") return current;

          let saved = null;
          try {
            saved = localStorage.getItem(key);
          } catch {
            saved = null;
          }
          if (saved === "dark" || saved === "light") return saved;

          let prefersDark = false;
          try {
            prefersDark = window
              .matchMedia("(prefers-color-scheme: dark)")
              .matches;
          } catch {
            prefersDark = false;
          }
          return prefersDark ? "dark" : "light";
        };

        let theme = getInitialTheme();
        document.documentElement.dataset.theme = theme;
        setButton(theme);

        btn.addEventListener("click", () => {
          theme = theme === "dark" ? "light" : "dark";
          document.documentElement.dataset.theme = theme;
          try {
            localStorage.setItem(key, theme);
          } catch {
            // ignore
          }
          setButton(theme);
        });
      })();

      // ===== External links: auto target=_blank + rel =====
      const normalizeRel = (a) => {
        const rel = (a.getAttribute("rel") ?? "")
          .split(/\s+/)
          .map((s) => s.trim())
          .filter(Boolean);

        if (!rel.includes("noopener")) rel.push("noopener");
        if (!rel.includes("noreferrer")) rel.push("noreferrer");

        a.setAttribute("rel", rel.join(" "));
      };

      const isSpecialProtocol = (href) =>
        href.startsWith("mailto:") ||
        href.startsWith("tel:") ||
        href.startsWith("sms:") ||
        href.startsWith("javascript:");

      const isAnchorOnly = (href) => href.startsWith("#");

      const isExternalUrl = (href) => {
        try {
          const u = new URL(href, window.location.href);
          return u.origin !== window.location.origin;
        } catch {
          return false;
        }
      };

      const applyExternalLinkPolicy = () => {
        document.querySelectorAll("a[href]").forEach((a) => {
          // ★ 完全に自動処理をスキップしたい
          if (a.hasAttribute("data-no-auto")) return;

          // ★ 外部でも同タブにしたい（既存）
          if (a.hasAttribute("data-same-tab")) return;

          const href = (a.getAttribute("href") ?? "").trim();
          if (!href) return;
          if (isAnchorOnly(href)) return;
          if (isSpecialProtocol(href)) return;

          const forceNewTab = a.hasAttribute("data-new-tab");

          // data-external="false" が付いてたら外部扱いしない（自動 _blank を抑止）
          const externalOverride = a.getAttribute("data-external");
          let external = isExternalUrl(href);
          if (externalOverride === "false") external = false;

          if (external || forceNewTab) {
            a.setAttribute("target", "_blank");
            normalizeRel(a);
          } else {
            // 内部リンクでも、手動で target=_blank の場合は rel を安全化
            if (a.getAttribute("target") === "_blank") {
              normalizeRel(a);
            }
          }
        });
      };

      applyExternalLinkPolicy();
    </script>
  </body>
</html>
